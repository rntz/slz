#ifndef _SLZ_H_
#define _SLZ_H_

#include <assert.h>
#include <setjmp.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

/* ---------- ON VERSION NUMBERS ----------
 *
 * To change version numbers, edit the Makefile.
 *
 * TODO: Separate the serialization format version from the library version.
 *
 * NB. The remainder of this comment is a collection of LIES. It serves as an
 * extended TODO. At present, if the version of the library and the encoded
 * value do not match, an error is raised. (YAGNI.)
 *
 * TODO:
 *
 * Consider a library with version "ml.il.bl" (format: "major.minor.bugfix").
 * Suppose it is attempting to read a chunk serialized by library with version
 * "sml.sil.sbl".
 *
 * If ml != sml, an error occurs. Major version changes indicate complete
 * incompatibilities. Otherwise:
 *
 * If il < sil, then a "soft" error occurs. Minor version increments indicate
 * new features which an older library may not be able to handle. However, the
 * library can be forced to try anyway, as it may succeed if the new minor
 * version's features were not exercised; hence, a "soft" error.
 *
 * Otherwise, everything is OK, unless "sml.sil.sbl" is known to have buggy
 * serialization, in which case a "soft" error is signalled.
 *
 * See slz_src_from_file and slz_sink_from_file for information about how errors
 * are signalled.
 */

typedef struct { uint16_t major, minor, bugfix; } slz_version_t;

typedef struct slz_src_funcs slz_src_funcs_t;
typedef struct slz_sink_funcs slz_sink_funcs_t;

typedef struct {
    bool error;
    slz_src_funcs_t *funcs;
    void *obj;
} slz_src_t;

typedef struct {
    bool error;
    slz_sink_funcs_t *funcs;
    void *obj;
} slz_sink_t;

/* Types of errors that can occur. */
typedef uint8_t slz_state_t;
enum slz_state {
    SLZ_OK,
    SLZ_IO_ERROR,               /* error generated by underlying src/sink */
    SLZ_BAD_HEADER,
    SLZ_UNFULFILLED_EXPECTATIONS,
    SLZ_OOM,
};

typedef uint8_t slz_origin_t;
enum slz_origin { SLZ_SRC, SLZ_SINK };

typedef struct slz_ctx slz_ctx_t;
struct slz_ctx {
    slz_state_t state;
    slz_origin_t origin_type;
    bool have_env;
    union {
        slz_src_t *src;
        slz_sink_t *sink;
    } origin;
    jmp_buf env;
    /* if this returns, we abort the program. */
    void (*toplevel_error_handler)(slz_ctx_t *ctx, void *userdata);
    void *userdata;
};

/* source and sink vtables */
struct slz_src_funcs {
    bool (*read)(void *obj, char *buf, size_t buflen);
    /* Returns 0 on success. Otherwise, returns the amount of space needed to
     * store the actual error message (including null byte), or SIZE_MAX to
     * indicate that the buffer was too small without actually indicating how
     * large it needs to be. (grr, POSIX strerror)
     */
    size_t (*strerror)(void *obj, char *buf, size_t buflen);
    /* Is NOT expected to close the underlying file, if any. We didn't open it,
     * so we don't close it. */
    void (*free)(void *obj);
};

struct slz_sink_funcs {
    bool (*write)(void *obj, const char *buf, size_t buflen);
    /* As strerror in slz_src_funcs. */
    size_t (*strerror)(void *obj, char *buf, size_t buflen);
    void (*free)(void *obj);
};


/* Miscellany. */
slz_version_t slz_version(void);
bool slz_compatible_version(slz_version_t version);


/* Error handling. */
void slz_init(
    slz_ctx_t *ctx,
    void (*handler)(slz_ctx_t*, void*),
    void *userdata);

/* Initializes `ctx' with a top-level error handler that prints the error,
 * perror-style (using `s'), and then aborts. */
void slz_init_with_perror(slz_ctx_t *ctx, const char *s);

static inline bool slz_ok(slz_ctx_t *ctx) {
    return ctx->state == SLZ_OK;
}

/* Precondition: !slz_ok(ctx).
 * NB. doesn't clear the error from src or sink that caused it.
 */
void slz_clear_error(slz_ctx_t *ctx);
/* Precondition: !slz_ok(ctx). */
void slz_perror(slz_ctx_t *ctx, const char *s);

/* Example use:
 *
 *     slz_ctx_t ctx;
 *     slz_src_t src;
 *     ... // initialize ctx, src
 *     if (slz_catch(&ctx)) {
 *         // An error occurred.
 *         slz_perror(&ctx, "myprog");
 *         exit(1);
 *     }
 *     // This is the code that can cause an error.
 *     int32_t val = slz_read_int32(&ctx, &src);
 *     ...
 *     slz_end_catch(&ctx);
 *
 * Note how the catch comes /before/ the code that can cause the error.
 */
#define slz_catch(ctx) ((bool) (setjmp(slz_PRIVATE_pre_catch((ctx))->env)))
void slz_end_catch(slz_ctx_t *ctx);

/* INTERNAL FUNCTION DO NOT USE.  */
static inline slz_ctx_t *slz_PRIVATE_pre_catch(slz_ctx_t *ctx) {
    assert (slz_ok(ctx) && !ctx->have_env);
    ctx->have_env = true;
    return ctx;
}


/* Sources & sinks. */
void slz_src_init(
    slz_ctx_t *ctx, slz_src_t *src, slz_src_funcs_t *funcs, void *obj);
void slz_sink_init(
    slz_ctx_t *ctx, slz_sink_t *src, slz_sink_funcs_t *funcs, void *obj);

void slz_src_from_file(slz_ctx_t *ctx, slz_src_t *src, FILE *file);
void slz_sink_from_file(slz_ctx_t *ctx, slz_sink_t *sink, FILE *file);

void slz_src_destroy(slz_ctx_t *ctx, slz_src_t *sink);
void slz_sink_destroy(slz_ctx_t *ctx, slz_sink_t *sink);


/* Serialization. */
void slz_put_bytes(
    slz_ctx_t *ctx, slz_sink_t *sink, size_t len, const char *data);

void slz_put_magic(slz_ctx_t *ctx, slz_sink_t *sink);

void slz_put_bool  (slz_ctx_t *ctx, slz_sink_t *sink,     bool val);
void slz_put_uint8 (slz_ctx_t *ctx, slz_sink_t *sink,  uint8_t val);
void slz_put_int8  (slz_ctx_t *ctx, slz_sink_t *sink,   int8_t val);
void slz_put_uint16(slz_ctx_t *ctx, slz_sink_t *sink, uint16_t val);
void slz_put_int16 (slz_ctx_t *ctx, slz_sink_t *sink,  int16_t val);
void slz_put_uint32(slz_ctx_t *ctx, slz_sink_t *sink, uint32_t val);
void slz_put_int32 (slz_ctx_t *ctx, slz_sink_t *sink,  int32_t val);
void slz_put_uint64(slz_ctx_t *ctx, slz_sink_t *sink, uint64_t val);
void slz_put_int64 (slz_ctx_t *ctx, slz_sink_t *sink,  int64_t val);


/* Deserialization. */
void slz_get_bytes(slz_ctx_t *ctx, slz_src_t *src, size_t len, char *out);

    bool slz_get_bool  (slz_ctx_t *ctx, slz_src_t *src);
 uint8_t slz_get_uint8 (slz_ctx_t *ctx, slz_src_t *src);
  int8_t slz_get_int8  (slz_ctx_t *ctx, slz_src_t *src);
uint16_t slz_get_uint16(slz_ctx_t *ctx, slz_src_t *src);
 int16_t slz_get_int16 (slz_ctx_t *ctx, slz_src_t *src);
uint32_t slz_get_uint32(slz_ctx_t *ctx, slz_src_t *src);
 int32_t slz_get_int32 (slz_ctx_t *ctx, slz_src_t *src);
uint64_t slz_get_uint64(slz_ctx_t *ctx, slz_src_t *src);
 int64_t slz_get_int64 (slz_ctx_t *ctx, slz_src_t *src);

void slz_expect_bytes(
    slz_ctx_t *ctx, slz_src_t *src, size_t len, const char *data);

/* Checks for the slz header and reads version number information. Does _not_
 * check version compatibility; use slz_compatible_version for that.
 */
slz_version_t slz_get_magic(slz_ctx_t *ctx, slz_src_t *src);

/* Checks the version number as well. */
void slz_expect_magic(slz_ctx_t *ctx, slz_src_t *src);

#endif
